# FamousToday
Alchemy signing key webhook 
1. whsec_Ka3G2XkXDVxzhdrFzG8n2OFq

2. whsec_rEV4KKHw57OALQ73encoFHDB ethermeum 

3. whsec_pa1W66wlvZyfLuESqE939OxD polygon matic

"X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"

Alchemy Auth token : jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp

Alchemy Webhook identifications
wh_pae2ekjly3q7fhx9 
Ethereum Mainnet
active
https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator

V2 wh_cktmaceotb7zou0i 
Polygon Mainnet

Alchemy Webhook signing key whsec_Ka3G2XkXDVxzhdrFzG8n2OFq

Alchemy api key 2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby

Auth token alchemy webhooks jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp
gem 'jwt', '~> 2.8', '>= 2.8.1'

gem install jwt

gem 'base64', '~> 0.2.0'

gem install base64
gem 'bundler', '~> 2.5', '>= 2.5.6'

gem install bundler

gem 'rubocop', '~> 1.62', '>= 1.62.1'
gem install rubocop
$ gem update --system
ruby setup.rb --help

+++NSA Black op +++
SHA-2 nist (ecdsa) cert.
AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= 

 "ssh_certificate_authority_id": "sshca_2bMmWjXfs30PrfyvCsxg79Bqea3",
 "principals": ["inconshreveable.com", "10.2.42.9"],
 "valid_after": "2024-01-23T18:09:15Z",
 "valid_until": "2024-04-22T18:09:15Z",
 "certificate": "ecdsa-sha2-nistp256-cert-v01@openssh.com AAAAKGVjZHNhLXNoYTItbmlzdHAyNTYtY2VydC12MDFAb3BlbnNzaC5jb20AAAAggnhUP6YZ1+Wj/NUNS9wN8yyJPgcDTNigqw0RlxX3HqAAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+CgkAAAAAAAAAAAAAAAIAAAAhc2hjcnRfMmJNbVdvQUZHVlJiTHhqT3hWWEF2dWNMaUF0AAAAJAAAABNpbmNvbnNocmV2ZWFibGUuY29tAAAACTEwLjIuNDIuOQAAAABlsADLAAAAAGYmp8sAAAAAAAAAAAAAAAAAAAAzAAAAC3NzaC1lZDI1NTE5AAAAIPbm5N4qnn+2CMXtrIfRXvUXDmTgkk/fcBHlR9dDAeY3AAAAUwAAAAtzc2gtZWQyNTUxOQAAAEATCa7CcaUJEVcAm2K7PaqeuJDE+pI+8PzMl+aPb9/YRAA72dMMy5izNNVLb7t7Cfqcyi4IGdd2TLFhFyVyayEE shcrt_2bMmWoAFGVRbLxjOxVXAvucLiAt"

Private key
SHA256:TvOWY3mZWlr9uMgny0PtyVdWFzAfKO98UgFlMzgP+ZA=
tar xzf ./actions-runner-linux-x64-2.313.0.tar.gz
GET https://github.com/login/oauth/authorize
This
https://smee.io/F1FDatOZAJIsTI
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq $>"

curl -v \
 'https://subgraph.satsuma-prod.com/< whsec_Ka3G2XkXDVxzhdrFzG8n2OFq >/<Stripe_M嗯InB拉扯呢agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz
$ npm install --global smee-client
Then the smee command will forward webhooks from smee.io to your local development environment.

$ smee -u https://smee.io/F1FDatOZAJIsTI
For usage info:
webhook this page : https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
$ smee --help
Use the Node.js client

$ npm install --save smee-client
Then:

const SmeeClient = require('smee-client')

const smee = new SmeeClient({
  source: 'https://smee.io/F1FDatOZAJIsTI',
  target: 'http://localhost:3000/events',
  logger: console
})

const events = smee.start()

// Stop forwarding events
events.close()
Using Probot's built-in support

$ npm install --save smee-client
Then set the environment variable:

WEBHOOK_PROXY_URL=https://smee.io/F1FDatOZAJIsTI
POST https://github.com/login/oauth/access_token

access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&scope=repo%2Cgist&token_type=bearer

Accept: application/json
{
  "access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a",
  "scope":"repo,gist",
  "token_type":"bearer"
}
Accept: application/xml
<OAuth>
  <token_type>bearer</token_type>
  <scope>repo,gist</scope>
  <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
</OAuth>
3. Use the access token to access the API

The access token allows you to make requests to the API on a behalf of a user.

Authorization: GitHub Runner token --token  --token A4D7THPUNN2ZH4SELLKJOITF3JIJS
GET https://api.github.com/user
For example, in curl you can set the Authorization header like this:

curl -H "Authorization: GitHub Runner token --token  --token A4D7THPUNN2ZH4SELLKJOITF3JIJS" https://api.github.com/user

POST https://github.com/login/device/code

device_code=3584d83530557fdd1f46af8289938c8ef79f9dc5&expires_in=900&interval=5&user_code=WDJB-MJHT&verification_uri=https%3A%2F%2Fgithub.com%2Flogin%2Fdevice

Accept: application/json
{
  "device_code": "3584d83530557fdd1f46af8289938c8ef79f9dc5",
  "user_code": "WDJB-MJHT",
  "verification_uri": "https://github.com/login/device",
  "expires_in": 900,
  "interval": 5
}
Accept: application/xml
<OAuth>
  <device_code>3584d83530557fdd1f46af8289938c8ef79f9dc5</device_code>
  <user_code>WDJB-MJHT</user_code>
  <verification_uri>https://github.com/login/device</verification_uri>
  <expires_in>900</expires_in>
  <interval>5</interval>
</OAuth>
Step 2: Prompt the user to enter the user code in a browser

Your device will show the user verification code and prompt the user to enter the code at https://github.com/login/device.

Step 3: App polls GitHub to check if the user authorized the device

POST https://github.com/login/oauth/access_token
Your app will make device authorization requests that poll POST https://github.com/login/oauth/access_token, until the device and user codes expire or the user has successfully authorized the app with a valid user code. The app must use the minimum polling interval retrieved in step 1 to avoid rate limit errors. For more information, see "Rate limits for the device flow."

The user must enter a valid code within 15 minutes (or 900 seconds). After 15 minutes, you will need to request a new device authorization code with POST https://github.com/login/device/code.

Once the user has authorized, the app will receive an access token that can be used to make requests to the API on behalf of a user.

The endpoint takes the following input parameters.

Parameter name Type Description
client_id string Required. The client ID you received from GitHub for your OAuth app.
device_code string Required. The device_code you received from the POST https://github.com/login/device/code request.
grant_type string Required. The grant type must be urn:ietf:params:oauth:grant-type:device_code.
By default, the response takes the following form:

access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&token_type=bearer&scope=repo%2Cgist
You can also receive the response in different formats if you provide the format in the Accept header. For example, Accept: application/json or Accept: application/xml:

Accept: application/json
{
 "access_token": "gho_16C7e42F292c6912E7710c838347Ae178B4a",


contract   graph init \      --product hosted-service     --from-contract &lt;CONTRACT_ADDRESS> \      [--network &lt;ETHEREUM_NETWORK>] \     [--abi &lt;FILE>] \      &lt;subgraph name>
cd <SUBGRAPH_DIRECTORY>
DEPLOY_KEY=dummy_key VERSION_LABEL=v0.0.3 npm run deploy
graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <skf75fXbMunwJ> \
  --ipfs https://ipfs.satsuma.xyz

  DEPLOY_KEY=dummy_key VERSION_LABEL=v0.0.3 npm run deploy
cd <SUBGRAPH_DIRECTORY>
npm install -g @graphprotocol/graph-cli
Create a new subgraph:

Bash

graph init --product hosted-service
Make modifications as necessary to the manifest, schema, and handlers.
See Developing a Subgraph for more details.
Deploying your subgraph

Get your deploy key from your Alchemy Dashboard.
Run the following:

Bash

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <DEPLOY_KEY>
  --ipfs https://ipfs.satsuma.xyz
graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <DEPLOY_KEY> \
  --ipfs https://ipfs.satsuma.xyz

Install the graph-cli:

Bash

npm install -g @graphprotocol/graph-cli
Create a new subgraph:

Bash

graph init --product hosted-service
Make modifications as necessary to the manifest, schema, and handlers.
See Developing a Subgraph for more details.
Deploying your subgraph

Get your deploy key from your Alchemy Dashboard.
Run the following:

Bash

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key <skf75fXbMunwJ>
  --ipfs https://ipfs.satsuma.xyz

  import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
{
  "jsonrpc": "2.0",
  "id": 0,
  "result": {
    "address": "0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be",
    "tokenBalances": [
      {
        "contractAddress": "0x0000000000085d4780b73119b644ae5ecd22b376",
        "tokenBalance": "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      ......
      {
        "contractAddress": "0x0abefb7611cb3a01ea3fad85f33c3c934f8e2cf4",
        "tokenBalance": "0x00000000000000000000000000000000000000000000039e431953bcb76c0000"
      },
      {
        "contractAddress": "0x0ad0ad3db75ee726a284cfafa118b091493938ef",
        "tokenBalance": "0x0000000000000000000000000000000000000000008d00cf60e47f03a33fe6e3"
      }
    ],
    "pageKey": "0x0ad0ad3db75ee726a284cfafa118b091493938ef"
  }
}
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'
curl https://eth-mainnet.g.alchemy.com/v2/demo \
-X POST \
-H "Content-Type: application/json" \
-d '{"jsonrpc":"2.0","method":"alchemy_getTokenBalances","params": ["0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be", "erc20"],"id":"42"}'
{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz

import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <skf75fXbMunwJ>

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <skf75fXbMunwJ>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz  



  import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
  curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz

import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz

  curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma

npm install -g @graphprotocol/graph-cli

graph init --product hosted-service

cd <SUBGRAPH_DIRECTORY>

graph deploy <SUBGRAPH_NAME> \
  --version-label <VERSION_NAME> \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
  --ipfs https://ipfs.satsuma.xyz

import { AlchemySigner } from "@alchemy/aa-alchemy";

export const signer = new AlchemySigner({
  client: {
    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
    // here to point to your backend.
    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
    iframeConfig: {
      // you will need to render a container with this id in your DOM
      iframeContainerId: "turnkey-iframe-container",
    },
  },
});
import { AlchemySigner } from "@alchemy/aa-alchemy";
import { useMutation } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";

export const SignupLoginComponent = () => {
  const [email, setEmail] = useState<string>("");

  // It is recommended you wrap this in React Context or other state management
  const signer = useMemo(
    () =>
      new AlchemySigner({
        client: {
          connection: {
            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
          },
          iframeConfig: {
            iframeContainerId: "turnkey-iframe-container",
          },
        },
      }),
    []
  );

  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
  const { mutate: loginOrSignup, isLoading } = useMutation({
    mutationFn: (email: string) =>
      signer.authenticate({ type: "email", email }),
  });

  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("bundle")) {
      // this will complete email auth
      signer
        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
        // redirect the user or do w/e you want once the user is authenticated
        .then(() => (window.location.href = "/"));
    }
  }, [signer]);

  // The below view allows you to collect the email from the user
  return (
    <>
      {!isLoading && (
        <div>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
          <button onClick={() => loginOrSignup(email)}>Submit</button>
        </div>
      )}
      <div id="turnkey-iframe-container" />
    </>
  );
};
import { signer } from "./signer";

// NOTE: this method throws if there is no authenticated user
// so we return null in the case of an error
const user = await signer.getAuthDetails().catch(() => null);

import { signer } from "./signer";

export const account = await createMultiOwnerModularAccount({
  transport: rpcTransport,
  chain,
  signer,
});
import { signer } from "./signer";
import { createWalletClient, http } from "viem";
import { sepolia } from "@alchemy/aa-core";

export const walletClient = createWalletClient({
  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
  chain: sepolia,
  account: signer.toViemAccount(),
});

$ python -m pip install requests
import requests

url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"

headers = {
    "accept": "application/json",
    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
}

response = requests.get(url, headers=headers)

print(response.text)

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
 -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'

curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
 -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"

curl -v \
 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

curl -v \
 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
  --data-raw '{"query":"{entities(first:1){id}}"}'

{
  "data": {
    "indexingStatusForCurrentVersion": {
      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
      "synced": true,
      "health": "healthy",
      "fatalError": null,
      "nonFatalErrors": [],
      "chains": [
        {
          "chainHeadBlock": {
            "number": "17787217"
          },
          "latestBlock": {
            "number": "17787217"
          }
        }
      ]
    }
  }
}

graph deploy example-subgraph-name \
  --version-label v0.0.1-new-version \
  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
  --deploy-key skf75fXbMunwJ \
  --ipfs https://ipfs.satsuma.xyz
  Alchemy Webhook signing key whsec_Ka3G2XkXDVxzhdrFzG8n2OFq

Alchemy api key 2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby

Auth token alchemy webhooks jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp
[PATCH] Update README.md

---
 README.md | 861 +++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 859 insertions(+), 2 deletions(-)

diff --git a/README.md b/README.md
index 317f73a..14583eb 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,223 @@
 # FamousToday
-contract   graph init \      --product hosted-service     --from-contract &lt;CONTRACT_ADDRESS> \      [--network &lt;ETHEREUM_NETWORK>] \     [--abi &lt;FILE>] \      &lt;subgraph name>
+Alchemy signing key webhook 
+1. whsec_Ka3G2XkXDVxzhdrFzG8n2OFq
+
+2. whsec_rEV4KKHw57OALQ73encoFHDB ethermeum 
+
+3. whsec_pa1W66wlvZyfLuESqE939OxD polygon matic
+
+"X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
+
+Alchemy Auth token : jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp
+
+Alchemy Webhook identifications
+wh_pae2ekjly3q7fhx9 
+Ethereum Mainnet
+active
+https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
+
+V2 wh_cktmaceotb7zou0i 
+Polygon Mainnet
+
+Alchemy Webhook signing key whsec_Ka3G2XkXDVxzhdrFzG8n2OFq
+
+Alchemy api key 2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby
+
+Auth token alchemy webhooks jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp
+gem 'jwt', '~> 2.8', '>= 2.8.1'
+
+gem install jwt
+
+gem 'base64', '~> 0.2.0'
+
+gem install base64
+gem 'bundler', '~> 2.5', '>= 2.5.6'
+
+gem install bundler
+
+gem 'rubocop', '~> 1.62', '>= 1.62.1'
+gem install rubocop
+$ gem update --system
+ruby setup.rb --help
+
++++NSA Black op +++
+SHA-2 nist (ecdsa) cert.
+AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+Cgk= 
+
+ "ssh_certificate_authority_id": "sshca_2bMmWjXfs30PrfyvCsxg79Bqea3",
+ "principals": ["inconshreveable.com", "10.2.42.9"],
+ "valid_after": "2024-01-23T18:09:15Z",
+ "valid_until": "2024-04-22T18:09:15Z",
+ "certificate": "ecdsa-sha2-nistp256-cert-v01@openssh.com AAAAKGVjZHNhLXNoYTItbmlzdHAyNTYtY2VydC12MDFAb3BlbnNzaC5jb20AAAAggnhUP6YZ1+Wj/NUNS9wN8yyJPgcDTNigqw0RlxX3HqAAAAAIbmlzdHAyNTYAAABBBI3oSgxrOEJ+tIJ/n6VYtxQIFvynqlOHpfOAJ4x4OfmMYDkbf8dr6RAuUSf+ZC2HMCujta7EjZ9t+6v08Ue+CgkAAAAAAAAAAAAAAAIAAAAhc2hjcnRfMmJNbVdvQUZHVlJiTHhqT3hWWEF2dWNMaUF0AAAAJAAAABNpbmNvbnNocmV2ZWFibGUuY29tAAAACTEwLjIuNDIuOQAAAABlsADLAAAAAGYmp8sAAAAAAAAAAAAAAAAAAAAzAAAAC3NzaC1lZDI1NTE5AAAAIPbm5N4qnn+2CMXtrIfRXvUXDmTgkk/fcBHlR9dDAeY3AAAAUwAAAAtzc2gtZWQyNTUxOQAAAEATCa7CcaUJEVcAm2K7PaqeuJDE+pI+8PzMl+aPb9/YRAA72dMMy5izNNVLb7t7Cfqcyi4IGdd2TLFhFyVyayEE shcrt_2bMmWoAFGVRbLxjOxVXAvucLiAt"
+
+Private key
+SHA256:TvOWY3mZWlr9uMgny0PtyVdWFzAfKO98UgFlMzgP+ZA=
+tar xzf ./actions-runner-linux-x64-2.313.0.tar.gz
+GET https://github.com/login/oauth/authorize
+This
+https://smee.io/F1FDatOZAJIsTI
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
+ -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
+ -H "Content-Type: application/json" -H "x-api-key: < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq $>"
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/< whsec_Ka3G2XkXDVxzhdrFzG8n2OFq >/<Stripe_M嗯InB拉扯呢agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+{
+  "data": {
+    "indexingStatusForCurrentVersion": {
+      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
+      "synced": true,
+      "health": "healthy",
+      "fatalError": null,
+      "nonFatalErrors": [],
+      "chains": [
+        {
+          "chainHeadBlock": {
+            "number": "17787217"
+          },
+          "latestBlock": {
+            "number": "17787217"
+          }
+        }
+      ]
+    }
+  }
+}
+
+graph deploy example-subgraph-name \
+  --version-label v0.0.1-new-version \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key skf75fXbMunwJ \
+  --ipfs https://ipfs.satsuma
+
+npm install -g @graphprotocol/graph-cli
+
+graph init --product hosted-service
+
 cd <SUBGRAPH_DIRECTORY>
 
+graph deploy <SUBGRAPH_NAME> \
+  --version-label <VERSION_NAME> \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
+  --ipfs https://ipfs.satsuma.xyz
+$ npm install --global smee-client
+Then the smee command will forward webhooks from smee.io to your local development environment.
+
+$ smee -u https://smee.io/F1FDatOZAJIsTI
+For usage info:
+webhook this page : https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator
+$ smee --help
+Use the Node.js client
+
+$ npm install --save smee-client
+Then:
+
+const SmeeClient = require('smee-client')
+
+const smee = new SmeeClient({
+  source: 'https://smee.io/F1FDatOZAJIsTI',
+  target: 'http://localhost:3000/events',
+  logger: console
+})
+
+const events = smee.start()
+
+// Stop forwarding events
+events.close()
+Using Probot's built-in support
+
+$ npm install --save smee-client
+Then set the environment variable:
+
+WEBHOOK_PROXY_URL=https://smee.io/F1FDatOZAJIsTI
+POST https://github.com/login/oauth/access_token
+
+access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&scope=repo%2Cgist&token_type=bearer
+
+Accept: application/json
+{
+  "access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a",
+  "scope":"repo,gist",
+  "token_type":"bearer"
+}
+Accept: application/xml
+<OAuth>
+  <token_type>bearer</token_type>
+  <scope>repo,gist</scope>
+  <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
+</OAuth>
+3. Use the access token to access the API
+
+The access token allows you to make requests to the API on a behalf of a user.
+
+Authorization: GitHub Runner token --token  --token A4D7THPUNN2ZH4SELLKJOITF3JIJS
+GET https://api.github.com/user
+For example, in curl you can set the Authorization header like this:
+
+curl -H "Authorization: GitHub Runner token --token  --token A4D7THPUNN2ZH4SELLKJOITF3JIJS" https://api.github.com/user
+
+POST https://github.com/login/device/code
+
+device_code=3584d83530557fdd1f46af8289938c8ef79f9dc5&expires_in=900&interval=5&user_code=WDJB-MJHT&verification_uri=https%3A%2F%2Fgithub.com%2Flogin%2Fdevice
+
+Accept: application/json
+{
+  "device_code": "3584d83530557fdd1f46af8289938c8ef79f9dc5",
+  "user_code": "WDJB-MJHT",
+  "verification_uri": "https://github.com/login/device",
+  "expires_in": 900,
+  "interval": 5
+}
+Accept: application/xml
+<OAuth>
+  <device_code>3584d83530557fdd1f46af8289938c8ef79f9dc5</device_code>
+  <user_code>WDJB-MJHT</user_code>
+  <verification_uri>https://github.com/login/device</verification_uri>
+  <expires_in>900</expires_in>
+  <interval>5</interval>
+</OAuth>
+Step 2: Prompt the user to enter the user code in a browser
+
+Your device will show the user verification code and prompt the user to enter the code at https://github.com/login/device.
+
+Step 3: App polls GitHub to check if the user authorized the device
+
+POST https://github.com/login/oauth/access_token
+Your app will make device authorization requests that poll POST https://github.com/login/oauth/access_token, until the device and user codes expire or the user has successfully authorized the app with a valid user code. The app must use the minimum polling interval retrieved in step 1 to avoid rate limit errors. For more information, see "Rate limits for the device flow."
+
+The user must enter a valid code within 15 minutes (or 900 seconds). After 15 minutes, you will need to request a new device authorization code with POST https://github.com/login/device/code.
+
+Once the user has authorized, the app will receive an access token that can be used to make requests to the API on behalf of a user.
+
+The endpoint takes the following input parameters.
+
+Parameter name Type Description
+client_id string Required. The client ID you received from GitHub for your OAuth app.
+device_code string Required. The device_code you received from the POST https://github.com/login/device/code request.
+grant_type string Required. The grant type must be urn:ietf:params:oauth:grant-type:device_code.
+By default, the response takes the following form:
+
+access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&token_type=bearer&scope=repo%2Cgist
+You can also receive the response in different formats if you provide the format in the Accept header. For example, Accept: application/json or Accept: application/xml:
+
+Accept: application/json
+{
+ "access_token": "gho_16C7e42F292c6912E7710c838347Ae178B4a",
+
+
+contract   graph init \      --product hosted-service     --from-contract &lt;CONTRACT_ADDRESS> \      [--network &lt;ETHEREUM_NETWORK>] \     [--abi &lt;FILE>] \      &lt;subgraph name>
+cd <SUBGRAPH_DIRECTORY>
+DEPLOY_KEY=dummy_key VERSION_LABEL=v0.0.3 npm run deploy
 graph deploy <SUBGRAPH_NAME> \
   --version-label <VERSION_NAME> \
   --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
@@ -9,7 +225,34 @@ graph deploy <SUBGRAPH_NAME> \
   --ipfs https://ipfs.satsuma.xyz
 
   DEPLOY_KEY=dummy_key VERSION_LABEL=v0.0.3 npm run deploy
+cd <SUBGRAPH_DIRECTORY>
+npm install -g @graphprotocol/graph-cli
+Create a new subgraph:
+
+Bash
+
+graph init --product hosted-service
+Make modifications as necessary to the manifest, schema, and handlers.
+See Developing a Subgraph for more details.
+Deploying your subgraph
 
+Get your deploy key from your Alchemy Dashboard.
+Run the following:
+
+Bash
+
+cd <SUBGRAPH_DIRECTORY>
+
+graph deploy <SUBGRAPH_NAME> \
+  --version-label <VERSION_NAME> \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key <DEPLOY_KEY>
+  --ipfs https://ipfs.satsuma.xyz
+graph deploy <SUBGRAPH_NAME> \
+  --version-label <VERSION_NAME> \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key <DEPLOY_KEY> \
+  --ipfs https://ipfs.satsuma.xyz
 
 Install the graph-cli:
 
@@ -417,5 +660,619 @@ graph deploy example-subgraph-name \
   --version-label v0.0.1-new-version \
   --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
   --deploy-key skf75fXbMunwJ \
-  --ipfs https://ipfs.satsuma.xyz
+  --ipfs https://ipfs.satsuma.xyz  
+
+
+
+  import { AlchemySigner } from "@alchemy/aa-alchemy";
+
+export const signer = new AlchemySigner({
+  client: {
+    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
+    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
+    // here to point to your backend.
+    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
+    iframeConfig: {
+      // you will need to render a container with this id in your DOM
+      iframeContainerId: "turnkey-iframe-container",
+    },
+  },
+});
+import { AlchemySigner } from "@alchemy/aa-alchemy";
+import { useMutation } from "@tanstack/react-query";
+import { useEffect, useMemo, useState } from "react";
+
+export const SignupLoginComponent = () => {
+  const [email, setEmail] = useState<string>("");
+
+  // It is recommended you wrap this in React Context or other state management
+  const signer = useMemo(
+    () =>
+      new AlchemySigner({
+        client: {
+          connection: {
+            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
+          },
+          iframeConfig: {
+            iframeContainerId: "turnkey-iframe-container",
+          },
+        },
+      }),
+    []
+  );
+
+  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
+  const { mutate: loginOrSignup, isLoading } = useMutation({
+    mutationFn: (email: string) =>
+      signer.authenticate({ type: "email", email }),
+  });
+
+  useEffect(() => {
+    const urlParams = new URLSearchParams(window.location.search);
+    if (urlParams.has("bundle")) {
+      // this will complete email auth
+      signer
+        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
+        // redirect the user or do w/e you want once the user is authenticated
+        .then(() => (window.location.href = "/"));
+    }
+  }, [signer]);
+
+  // The below view allows you to collect the email from the user
+  return (
+    <>
+      {!isLoading && (
+        <div>
+          <input
+            type="email"
+            value={email}
+            onChange={(e) => setEmail(e.target.value)}
+          />
+          <button onClick={() => loginOrSignup(email)}>Submit</button>
+        </div>
+      )}
+      <div id="turnkey-iframe-container" />
+    </>
+  );
+};
+import { signer } from "./signer";
+
+// NOTE: this method throws if there is no authenticated user
+// so we return null in the case of an error
+const user = await signer.getAuthDetails().catch(() => null);
+
+import { signer } from "./signer";
+
+export const account = await createMultiOwnerModularAccount({
+  transport: rpcTransport,
+  chain,
+  signer,
+});
+import { signer } from "./signer";
+import { createWalletClient, http } from "viem";
+import { sepolia } from "@alchemy/aa-core";
+
+export const walletClient = createWalletClient({
+  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
+  chain: sepolia,
+  account: signer.toViemAccount(),
+});
+
+$ python -m pip install requests
+import requests
+
+url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"
+
+headers = {
+    "accept": "application/json",
+    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
+}
+
+response = requests.get(url, headers=headers)
+
+print(response.text)
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
+ -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
+ -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+{
+  "data": {
+    "indexingStatusForCurrentVersion": {
+      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
+      "synced": true,
+      "health": "healthy",
+      "fatalError": null,
+      "nonFatalErrors": [],
+      "chains": [
+        {
+          "chainHeadBlock": {
+            "number": "17787217"
+          },
+          "latestBlock": {
+            "number": "17787217"
+          }
+        }
+      ]
+    }
+  }
+}
+
+graph deploy example-subgraph-name \
+  --version-label v0.0.1-new-version \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key skf75fXbMunwJ \
+  --ipfs https://ipfs.satsuma.xyz
+  curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
+ -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
+ -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+{
+  "data": {
+    "indexingStatusForCurrentVersion": {
+      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
+      "synced": true,
+      "health": "healthy",
+      "fatalError": null,
+      "nonFatalErrors": [],
+      "chains": [
+        {
+          "chainHeadBlock": {
+            "number": "17787217"
+          },
+          "latestBlock": {
+            "number": "17787217"
+          }
+        }
+      ]
+    }
+  }
+}
+
+graph deploy example-subgraph-name \
+  --version-label v0.0.1-new-version \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key skf75fXbMunwJ \
+  --ipfs https://ipfs.satsuma
+
+npm install -g @graphprotocol/graph-cli
+
+graph init --product hosted-service
+
+cd <SUBGRAPH_DIRECTORY>
+
+graph deploy <SUBGRAPH_NAME> \
+  --version-label <VERSION_NAME> \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
+  --ipfs https://ipfs.satsuma.xyz
+
+import { AlchemySigner } from "@alchemy/aa-alchemy";
+
+export const signer = new AlchemySigner({
+  client: {
+    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
+    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
+    // here to point to your backend.
+    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
+    iframeConfig: {
+      // you will need to render a container with this id in your DOM
+      iframeContainerId: "turnkey-iframe-container",
+    },
+  },
+});
+import { AlchemySigner } from "@alchemy/aa-alchemy";
+import { useMutation } from "@tanstack/react-query";
+import { useEffect, useMemo, useState } from "react";
+
+export const SignupLoginComponent = () => {
+  const [email, setEmail] = useState<string>("");
+
+  // It is recommended you wrap this in React Context or other state management
+  const signer = useMemo(
+    () =>
+      new AlchemySigner({
+        client: {
+          connection: {
+            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
+          },
+          iframeConfig: {
+            iframeContainerId: "turnkey-iframe-container",
+          },
+        },
+      }),
+    []
+  );
+
+  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
+  const { mutate: loginOrSignup, isLoading } = useMutation({
+    mutationFn: (email: string) =>
+      signer.authenticate({ type: "email", email }),
+  });
+
+  useEffect(() => {
+    const urlParams = new URLSearchParams(window.location.search);
+    if (urlParams.has("bundle")) {
+      // this will complete email auth
+      signer
+        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
+        // redirect the user or do w/e you want once the user is authenticated
+        .then(() => (window.location.href = "/"));
+    }
+  }, [signer]);
+
+  // The below view allows you to collect the email from the user
+  return (
+    <>
+      {!isLoading && (
+        <div>
+          <input
+            type="email"
+            value={email}
+            onChange={(e) => setEmail(e.target.value)}
+          />
+          <button onClick={() => loginOrSignup(email)}>Submit</button>
+        </div>
+      )}
+      <div id="turnkey-iframe-container" />
+    </>
+  );
+};
+import { signer } from "./signer";
+
+// NOTE: this method throws if there is no authenticated user
+// so we return null in the case of an error
+const user = await signer.getAuthDetails().catch(() => null);
+
+import { signer } from "./signer";
+
+export const account = await createMultiOwnerModularAccount({
+  transport: rpcTransport,
+  chain,
+  signer,
+});
+import { signer } from "./signer";
+import { createWalletClient, http } from "viem";
+import { sepolia } from "@alchemy/aa-core";
+
+export const walletClient = createWalletClient({
+  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
+  chain: sepolia,
+  account: signer.toViemAccount(),
+});
+
+$ python -m pip install requests
+import requests
+
+url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"
+
+headers = {
+    "accept": "application/json",
+    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
+}
+
+response = requests.get(url, headers=headers)
+
+print(response.text)
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
+ -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
+ -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+{
+  "data": {
+    "indexingStatusForCurrentVersion": {
+      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
+      "synced": true,
+      "health": "healthy",
+      "fatalError": null,
+      "nonFatalErrors": [],
+      "chains": [
+        {
+          "chainHeadBlock": {
+            "number": "17787217"
+          },
+          "latestBlock": {
+            "number": "17787217"
+          }
+        }
+      ]
+    }
+  }
+}
+
+graph deploy example-subgraph-name \
+  --version-label v0.0.1-new-version \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key skf75fXbMunwJ \
+  --ipfs https://ipfs.satsuma.xyz
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
+ -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
+ -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+{
+  "data": {
+    "indexingStatusForCurrentVersion": {
+      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
+      "synced": true,
+      "health": "healthy",
+      "fatalError": null,
+      "nonFatalErrors": [],
+      "chains": [
+        {
+          "chainHeadBlock": {
+            "number": "17787217"
+          },
+          "latestBlock": {
+            "number": "17787217"
+          }
+        }
+      ]
+    }
+  }
+}
+
+graph deploy example-subgraph-name \
+  --version-label v0.0.1-new-version \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key skf75fXbMunwJ \
+  --ipfs https://ipfs.satsuma.xyz
+
+  curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
+ -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
+ -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>"
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<Stripe_Men In Black agency>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq Y>' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+{
+  "data": {
+    "indexingStatusForCurrentVersion": {
+      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
+      "synced": true,
+      "health": "healthy",
+      "fatalError": null,
+      "nonFatalErrors": [],
+      "chains": [
+        {
+          "chainHeadBlock": {
+            "number": "17787217"
+          },
+          "latestBlock": {
+            "number": "17787217"
+          }
+        }
+      ]
+    }
+  }
+}
+
+graph deploy example-subgraph-name \
+  --version-label v0.0.1-new-version \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key skf75fXbMunwJ \
+  --ipfs https://ipfs.satsuma
+
+npm install -g @graphprotocol/graph-cli
+
+graph init --product hosted-service
+
+cd <SUBGRAPH_DIRECTORY>
+
+graph deploy <SUBGRAPH_NAME> \
+  --version-label <VERSION_NAME> \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key < whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>
+  --ipfs https://ipfs.satsuma.xyz
+
+import { AlchemySigner } from "@alchemy/aa-alchemy";
+
+export const signer = new AlchemySigner({
+  client: {
+    // This is created in your dashboard under `https://dashboard.alchemy.com/settings/access-keys`
+    // NOTE: it is not recommended to expose your API key on the client, instead proxy requests to your backend and set the `rpcUrl`
+    // here to point to your backend.
+    connection: { apiKey: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>" },
+    iframeConfig: {
+      // you will need to render a container with this id in your DOM
+      iframeContainerId: "turnkey-iframe-container",
+    },
+  },
+});
+import { AlchemySigner } from "@alchemy/aa-alchemy";
+import { useMutation } from "@tanstack/react-query";
+import { useEffect, useMemo, useState } from "react";
+
+export const SignupLoginComponent = () => {
+  const [email, setEmail] = useState<string>("");
+
+  // It is recommended you wrap this in React Context or other state management
+  const signer = useMemo(
+    () =>
+      new AlchemySigner({
+        client: {
+          connection: {
+            jwt: "alcht_<2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby>",
+          },
+          iframeConfig: {
+            iframeContainerId: "turnkey-iframe-container",
+          },
+        },
+      }),
+    []
+  );
+
+  // we are using react-query to handle loading states more easily, but feel free to use w/e state management library you prefer
+  const { mutate: loginOrSignup, isLoading } = useMutation({
+    mutationFn: (email: string) =>
+      signer.authenticate({ type: "email", email }),
+  });
+
+  useEffect(() => {
+    const urlParams = new URLSearchParams(window.location.search);
+    if (urlParams.has("bundle")) {
+      // this will complete email auth
+      signer
+        .authenticate({ type: "email", bundle: urlParams.get("bundle")! })
+        // redirect the user or do w/e you want once the user is authenticated
+        .then(() => (window.location.href = "/"));
+    }
+  }, [signer]);
+
+  // The below view allows you to collect the email from the user
+  return (
+    <>
+      {!isLoading && (
+        <div>
+          <input
+            type="email"
+            value={email}
+            onChange={(e) => setEmail(e.target.value)}
+          />
+          <button onClick={() => loginOrSignup(email)}>Submit</button>
+        </div>
+      )}
+      <div id="turnkey-iframe-container" />
+    </>
+  );
+};
+import { signer } from "./signer";
+
+// NOTE: this method throws if there is no authenticated user
+// so we return null in the case of an error
+const user = await signer.getAuthDetails().catch(() => null);
+
+import { signer } from "./signer";
+
+export const account = await createMultiOwnerModularAccount({
+  transport: rpcTransport,
+  chain,
+  signer,
+});
+import { signer } from "./signer";
+import { createWalletClient, http } from "viem";
+import { sepolia } from "@alchemy/aa-core";
+
+export const walletClient = createWalletClient({
+  transport: http("[alchemy_rpc_url](https://scpf-foundation-roblox.fandom.com/wiki/The_Administrator)"),
+  chain: sepolia,
+  account: signer.toViemAccount(),
+});
+
+$ python -m pip install requests
+import requests
+
+url = "https://dashboard.alchemy.com/api/webhook-addresses?webhook_id=https%3A%2F%2Fscpf-foundation-roblox.fandom.com%2Fwiki%2FThe_Administrator&limit=1000&after=19"
+
+headers = {
+    "accept": "application/json",
+    "X-Alchemy-Token": "2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby"
+}
+
+response = requests.get(url, headers=headers)
+
+print(response.text)
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/promote-live \
+ -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>'
+
+curl -X POST https://subgraphs.alchemy.com/api/subgraphs/<TEAM ID>/<SUBGRAPH_NAME>/<VERSION_NAME>/auto-promote-live \
+ -H "Content-Type: application/json" -H "x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq"
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<QUERY_KEY>/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+curl -v \
+ 'https://subgraph.satsuma-prod.com/<ORGANIZATION>/<SUBGRAPH_NAME>/version/<VERSION_NAME>/api' \
+  -H 'x-api-key: <whsec_Ka3G2XkXDVxzhdrFzG8n2OFq>' \
+  --data-raw '{"query":"{entities(first:1){id}}"}'
+
+{
+  "data": {
+    "indexingStatusForCurrentVersion": {
+      "subgraph": "QmXqNgptc2b5WzwmFfCu8PxsLgetBe5M8eBKvSyu5jqkei",
+      "synced": true,
+      "health": "healthy",
+      "fatalError": null,
+      "nonFatalErrors": [],
+      "chains": [
+        {
+          "chainHeadBlock": {
+            "number": "17787217"
+          },
+          "latestBlock": {
+            "number": "17787217"
+          }
+        }
+      ]
+    }
+  }
+}
+
+graph deploy example-subgraph-name \
+  --version-label v0.0.1-new-version \
+  --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
+  --deploy-key skf75fXbMunwJ \
+  --ipfs https://ipfs.satsuma.xyz
+  Alchemy Webhook signing key whsec_Ka3G2XkXDVxzhdrFzG8n2OFq
+
+Alchemy api key 2_30hERlJhrpl9Tgt1a5sX9D7NA_9cby
+
+Auth token alchemy webhooks jE92Hk8uCBZnJEh1PP0PoUVDwnuYFdVp


  
